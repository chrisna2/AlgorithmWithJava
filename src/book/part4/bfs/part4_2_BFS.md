# 자바로 쉽게 배우는 알고리즘 - part 4 - 2 : 기본적인 그래프 알고리즘 - 너비 우선 탐색 알고리즘
## 깊이 우선 탐색 알고리즘 (Breadth - First Search : BFS)
- 시작 정점에서 인접한 정점들을 모두 방문한 뒤에 이 정점들에 인접한 방문하지 않은 정점들을 모두 방문
- 시작 정점에서 인접한 모든 정점들을 방문할 때까지 계속된다
- 정점들을 시작 정점까지의 최단 경로의 길이 순서대로 방문
- 탐색이 종료된뒤 아직 방문하지 못한 정점이 남은 경우 그 정점들중 한 정점에서 너비 우선 탐색을 실시함
![DFS](/images/bfs.png)
- 그림 출처 : https://gmlwjd9405.github.io/2018/08/14/algorithm-bfs.html

## 알고리즘 구조 

```java

알고리즘 BFSearch(G)
// 주어진 그래프를 너비 우선 탐색으로 순회한다.
// 입력 : 그래프 G = (V, E)
// 출력 : 각 정점이 "방문함"으로 표시된 그래프 G와 너비 우선 탐색에서 처음으로 방문하는 순서대로 출력된 정점들

    1. V에  있는 각 정점을 '방문안함'으로 표시한다.
    2. 각 정점 v ∈ V 에 대해 다음을 수행한다:
         v가 '방문안함'으로 표시되어 있다면 BFS(v)를 호출한다.

BFS(v)
// 정점 v에 연결된 방문하지 않은 모든 정점들을 방문한다.
    
    1. v를 '방문함'으로 표시한다.
    2. v를 큐의 끝으로 추가한다.
    3. 큐가 비어 있지 않은 동안 다음을 수행한다.
        3.1 큐의 맨 앞에 있는 정점을 끄집어내어 element에 저장한다.
        3.2 element의 데이터를 출력한다.
        3.3 element에 인접한 모든 정점 w ∈ V 에 대해 다음을 수행한다:
            w가 '방문안함'으로 표시되어 있다면 w를 '방문함'으로 표시한뒤 w를 큐의 끝에 추가한다.

```
- 깊이 우선 탐색과는 다르게 재귀를 사용한여 작성할 수 없는 유형
- 큐(Queue)를 사용하여 쉽게 작성할 수 있다. (First in First out)
- 큐는 처음에 시작한 정점으로 초기화된다.
- 시작 정점은 '방문함'으로 표시된다.
- 반복할 때마다. 알고리즘은 큐의 맨 앞에 있는 정점에 인접한 정점들을 찾아낸 후 방문한으로 표시하고 큐에 끝에 정점을 추가한다. 그리고 나서 맨 앞에 있는 정점을 큐에서 끄집어 낸다. 

## 너비 우선 신장 트리
- 너비 우선 탐색의 결과로 우선 신장 트리를 만들수 있다.
- 너비 우선 탐색의 시작 정점은 트리의 루트노드가 된다.
- 한 정점 A에 인접한 정점 B를 처음으로 방문할 때 B는 A의 자식 노드가 된다.
- A 에서 B로 가는 간선은 트리 안에 포함되며 트리간선이라고 부른다.
- 너비 우선 탐색에서 한 정점엄에서 트리의 부모 노드가 아닌 이미 방문한 정점으로 가는 간선을 만날때 그 간선은 교차간선이라고 부르며 점선으로 표현된다.
- 너비 우선 탐색에서 모든 정점들을 방문한 경우 그래프가 모두 연결되며 이 트리를 너비 우선 신장 트리를 형성한다고 한다.
- 그래프가 연결되지 않은 경우 너비 우선 신장 숲을 형성한다.

## 너비 우선 탐색 트리 알고리즘 구현

```java

BreadthFirstSearch.java 참조

    public void BFS(Node v){

        // v를 '방문함'으로 표시한다. 
        v.visited = true;

        // v를 큐에 추가한다.
        queue.add(v);

        while(!queue.isEmpty()){

            //큐 맨 앞에 있는 정점을 끄집어 내어 element에 저장한다.
            Node element = queue.remove();
            
            // elemnet에 인접한 정점들의 연결 목록을 끄집어 낸다.
            List<Node> neighbours = element.getNeighbours();

            // 정점 V에 대응되는 데이터를 출력한다.
            System.out.print("["+element.info+"]");
            System.out.print("의 이웃 정점 -> "+neighbours.toString());
            System.out.println(" | 남은 queue -> "+queue.toString());
            
            
            //element에 인접한 방문하지 않은 모든 정점들에 대해 너비우선 탐색을 수행한다.
            for(int i=0;i<neighbours.size();i++){
                //w는 element에 인접한 정점
                Node w = neighbours.get(i);

                if(w != null && !w.visited){
                    //w가 '방문안함'으로 표시된 경우
                    //w를 '방문함'으로 표시한다.
                    w.visited = true;
                    queue.add(w);//다시 큐 끝으로 추가한다.
                    System.out.println(" -> "+w.info + " 방문함 : 해당 정점의 이웃정점들을 탐색하기 위해 queue 등록 => "+queue.toString());
                }
                else{
                    System.out.print(" -> "+w.info);
                    if(w.visited){
                        System.out.println(" 이미 방문");
                    }
                }
            }
        }
    }

```

## 결과

```linux

너비 우선 탐색 실행 결과 :
[1]의 이웃 정점 -> [2, 3, 5] | 남은 queue -> []
 -> 2 방문함 : 해당 정점의 이웃정점들을 탐색하기 위해 queue 등록 => [2]      
 -> 3 방문함 : 해당 정점의 이웃정점들을 탐색하기 위해 queue 등록 => [2, 3]   
 -> 5 방문함 : 해당 정점의 이웃정점들을 탐색하기 위해 queue 등록 => [2, 3, 5]
[2]의 이웃 정점 -> [1, 3] | 남은 queue -> [3, 5]
 -> 1 이미 방문
 -> 3 이미 방문
[3]의 이웃 정점 -> [1, 2, 4, 5] | 남은 queue -> [5]
 -> 1 이미 방문
 -> 2 이미 방문
 -> 4 방문함 : 해당 정점의 이웃정점들을 탐색하기 위해 queue 등록 => [5, 4]   
 -> 5 이미 방문
[5]의 이웃 정점 -> [1, 3] | 남은 queue -> [4]
 -> 1 이미 방문
 -> 3 이미 방문
[4]의 이웃 정점 -> [3, 6] | 남은 queue -> []
 -> 3 이미 방문
 -> 6 방문함 : 해당 정점의 이웃정점들을 탐색하기 위해 queue 등록 => [6]      
[6]의 이웃 정점 -> [3, 4] | 남은 queue -> []
 -> 3 이미 방문
 -> 4 이미 방문

```

## 효용성 및 특징
- 두 노드 사이의 최단 경로 혹은 임의의 경로를 찾고 싶을 때 이 방법을 사용
    - 회사에 있는 구성원의 모든 관계를 그래프로 표현한 뒤 임의 A와 B의 사이에 존재한는 모든 경로를 찾는 경우
    - 깊이 우선 탐색을 하는 경우 : 모든 관계를 다 살피고 나서 A와 B사이 경로를 찾음
    - 너비 우선 탐색의 경우 : A의 주변 관계에서 부터 탐색을 시작함
- 너비 우선 탐새의 경우 깊이 우선 탐색보다 좀 더 복잡하다.
- 직관적이지 않은 편 : 시작 노드에서 시작하여 거리에 따라 단계별로 탐색
- 재귀 함수 x , Queue O
- 그러나 깊이 우선 탐색과 마찬가지로 반드시 노드 방문시 방문여부를 표시해야 함 -> 무한루프 위험성 있음
- 그래프의 연결여부, 순환그래프확인, 두 정점의 최소 경로 찾기에 활용