# 자바로 쉽게 배우는 알고리즘 - part 3 : 정렬알고리즘
### 20220905 : 정렬부터 간다. 진도를 나간다. 문제는 나중에 푼다. 배경지식을 쌓는다.

## 정렬알고리즘
- 정렬 알고리즘은 컴퓨터 과학 중 가장 많이 연구된 분야
- 정렬은 정렬대상의 수가 증가할 수록 정렬의 단위 비용은 줄어들지 않고 더 늘어남

## 정렬 알고리즘의 분류
1. 배열의 크기에 기초해 나눈 후 배열을 합쳐서 정렬한다.
    > 1. 크기가 1인 배열과 크기가(n-1)인 배열로 나눈다
    >> ex) 삽입정렬 
    > 2. 크기가 n/2인 두 개의 배열로 나눈다.
    >> ex) 합병정렬

    &rightarrow; 여기에 해당 하는 정렬 알고리즘은 나누는 것은 쉽고 합치는 것은 어렵다. 

2. 배열의 특정 값에 기초하여 나눈 후 배열들을 합쳐서 정렬한다
    > 1. 최솟값에 기초하여 배열을 나눈다.
    >> ex) 선택정렬, 힙정렬
    > 2. 배열의 기준 값(예. 첫번째 값)에 기초하여 배열을 나눈다.
    >> ex) 빠른정렬

    &rightarrow; 여기에 해당 하는 정렬 알고리즘은 나누는 것은 어렵고 합치는 것은 쉽다.

## 선택정렬
> ***전체배열(0<N)에서 가장 작은 요소를 찾고, 그 요소를 첫번쨰 요소와 교환한다.***  
> ***&rightarrow; 두번째요소 부터 다음요소까지 가장 작은 요소를 찾고 그 요소를 두번째 요소와 교환한다.***  
> ***&rightarrow; 이 것을 (n-1)번 반복한다.***  

```java
SelectionSort.java 참조

        int i, j, min, temp;
        int n = arr.length;

        for(i=0;i<n-1;i++){
            //arr[i] 부터 arr[n-1] 까지 요소들 중 가장 작은 최소 값의 지수를 찾는다.
            min = i;
            for(j=i+1; j<n; j++){
                if(arr[j]<arr[min]){
                    min = j;
                }
            }
            //arr[i] 와 arr[min]을 교환한다.
            temp = arr[min];
            arr[min] = arr[i];
            arr[i] = temp;
        }
```  

- 선택정렬의 알고리즘 시간 복잡도 (10번의 비교 시)  
    > 첫번째요소 체크 : 총 9번 비교 처리  
    > 두번째요소 체크 : 총 8번 비교 처리
    > ___
    > 열번째요소 체크 : 총 1번 비교 처리

        -> 10 + 9 + 8 ... + 1 = 55번 비교 
        => 1 ~ n 까지의 총합 공식
        => n(n-1)/2 ∈ O(n^2) : 2차 선형 시간 복잡도 

- 이해하기는 쉽지만 빠른 알고리즘이 아니다.

## 삽입정렬
> ***전체배열(0<N)에서 A[0] , A[1 ~ n-1]을 배열로 나눈다.***  
> ***&rightarrow; A[0]와 A[1]을 비교하여 A[1]을 첫번째 배열의 적절한 위치에 삽입 정렬한다..***  
> ***&rightarrow; A[0 ~1]과 A[2]를 비교하여 A[1]을 첫번째 배열의 적절한 위치에 삽입 정렬한다..***  
> ***&rightarrow; A[0 ~ n-2]과 A[n-1]를 비교하여 A[n-1]을 첫번째 배열의 적절한 위치에 삽입 정렬한다..***  
> ***&rightarrow; 첫번째 배열만 남고 정렬이 완료된다.***  

- 삽입정렬의 알고리즘 골격
```java
for(i=1;i<n;i++){
    A[0..i]를 "재배열"하여 정렬한다.
}
```
- 여기서 **"재배열"** 이 중요함 -> 여기선 선택 정렬을 사용함
- 첫번째요소 작은 요소부터 위로 순차적으로 비교하면서 찾거나 -> 숫자가 작을 수록 인덱스 수정이 많아짐
- 마지막요소 큰 요소부터 아래로 순차적으로 비교하면서 찾거나 -> 주로 사용




