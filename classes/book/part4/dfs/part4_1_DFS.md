# 자바로 쉽게 배우는 알고리즘 - part 4 - 1 : 기본적인 그래프 알고리즘 - 깊이 우선 탐색 알고리즘
## 깊이 우선 탐색 알고리즘 (Depth - First Search : DFS)
- 임의의 그래프의 정점 A에서 부터 시작.
- 정점 A의 인접한 정점 가운데 임의 정점을 탐색,
- 탐색한 정점을 탐색을 했다고 표시하고 해당 정점에서 방문하지 않은 정점을 탐색
- 최종적으로 인접한 지점이 없는 경우 정점 A의 다음 정점에서 다시 시작하여 방문하지 않은 정점을 탐색하여 반복적으토 탐색을 실행
- 시작 정점으로 돌아간 뒤에 그 시작 정점에 인접한 정점 가운데 방문안한 정점이 없으면 탐색 종료
![DFS](/images/dfs.png)
- 그림 출처 : https://gmlwjd9405.github.io/2018/08/14/algorithm-dfs.html

## 알고리즘 구조

``` java
알고리즘 DFSearcb(G)
// 주어진 그래프를 깊이 우선 탐색으로 순회한다.
// 입력 : 그래프 G = (V,E)
// 출력 : 각 정점이 방문한으로 표시된 그래프 G와 깊이 우선 탐색에서 처음으로 방문하는 순서대로 출력된 정점들

    1. V에 있는 각 정점을 방문안함으로 표시한다.
    2. 각 정점 v ∈ V 에 대해 다음을 수행 함
        => v가 방문안함으로 표시된경우 메서드 DFS(v)를 호출 한다.

메서드 DFS(v)
// 정점 v에 연결된 방문하지 않은 모든 정점들을 재귀적으로 방문처리한다.

    1. v의 데이터를 출력한다.
    2. v를 방문함으로 표시한다.
    3. v에 인접한 모든 정점 w ∈ V 에 대해 다음을 수행한다.
        -> w가 방문안함으로 표시되어 있다면 DFS(w)를 호출 한다.
```

- 깊이 우선 탐색의 결과는 깊이 우선 신장 트리로 만들 수 있다.
- 깊이 우선 탐색의 시작 점점은 해당 트리의 루트 노드가 된다.
- 한 정점 A에 인접한 새 정점 B를 처음으로 방문할 때 트리에서 B는 A의 자식 노드가 된다.
- 이 경우 A에서 B로 가는 간선을 트리 안에 포함되고 트리 간선이라고 부르며 실선으로 표시 된다.
- 트리의 부모 노드가 아닌 이미 방문한 정점으로 가는 간선을 만날때 그 간선은 뒤 간선(back edge)이라고 부르며 점선으로 표시된다.
- 깊이 우선 탐색에서 그래프가 연결되어 있다면 모든 정점들을 방문하게 되는 것이고 이 경우 트리의 간선들을 깇이 우선 신장 트리를 형성한다.
- 그래프가 연결되지 않다면 깊이 우선 신장 숲을 만든다. 


## 실제 코드 구현

``` java 
    //DepthFirstSearch.java 참조

        public static void DFS(Node v){

        // 정점 V에 대응되는 데이터를 출력한다.
        System.out.print("★["+v.info+"]");

        // 정점 v를 '방문함'으로 표시한다.
        v.visited = true;

        // 정점 v에 인접한 정점들의 연결 목록을 끄집어 낸다.
        List<Node> neighbours = v.neighbours;

        System.out.println("의 이웃 정점 -> "+neighbours.toString());

        // 정점 v에 인접한 방문하지 않은 모든 정점들에 대해 깊이 우선 탐색을 수행한다.
        for(int i = 0; i < neighbours.size(); i++){            
            Node w = neighbours.get(i);
            if(w != null && !w.visited){
                System.out.println("방문 대상 -> "+w.info);
                DFS(w);
            }
            else{
                System.out.print("탐색 노드 -> "+w.info);
                if(w.visited){
                    System.out.println(" 이미 방문함");
                }
            }
        }
        System.out.println("["+v.info+"]의 이전 분기로 돌아감");
    }
```
## 결과

```linux
재귀를 사용한 깊이 우선 탐색 실행 결과
★ [1]의 이웃 정점 -> [2, 3, 5]   
1 -> 2
    ★ [2]의 이웃 정점 -> [1, 3]      
    2 -> 1 이미 방문
    2 -> 3
        ★ [3]의 이웃 정점 -> [1, 2, 4, 5]
        3 -> 1 이미 방문
        3 -> 2 이미 방문
        3 -> 4
            ★ [4]의 이웃 정점 -> [3, 6]      
            4 -> 3 이미 방문
            4 -> 6
                ★ [6]의 이웃 정점 -> [3, 4]      
                6 -> 3 이미 방문
                6 -> 4 이미 방문
                [6]의 이전 분기로 돌아감
            [4]의 이전 분기로 돌아감
        3 -> 5
            ★ [5]의 이웃 정점 -> [1, 3]      
            5 -> 1 이미 방문
            5 -> 3 이미 방문
            [5]의 이전 분기로 돌아감
        [3]의 이전 분기로 돌아감
    [2]의 이전 분기로 돌아감
1 -> 3 이미 방문
1 -> 5 이미 방문
[1]의 이전 분기로 돌아감
BFS 탐색 종료

```

## 효용성 및 특징
- 미로를 탐색할때 한 방향으로 갈 수 있을 때까지 계속 가다가 더 이상 갈수 없게되면 이전 분기로 돌아와 다른 방향으로 탐색을 진행하는 방법
- **모든 정점을 탐색 하고자 하는 경우** 사용 
- 단순 검색 속도는 넓이 우선 탐색에 비해 느린편
- 재귀 알고리즘 형태를 취함
- 그래프 탐색시 어떤 노드를 방문해쓴지 여부를 반드시 검사해야함 -> 무한 루프에 빠짐